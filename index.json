[{"categories":["Resume"],"content":"张宇豪 | Java开发工程师 ","date":"2022-02-22","objectID":"/resume/:1:0","tags":["Resume"],"title":"简历","uri":"/resume/"},{"categories":["Resume"],"content":"基本信息 Tel: 17887100968 QQ: 475393043 WeChat: Guxianggu e-mail: mustard_gxg@foxmail.com Blog: https://buli-home.cn ","date":"2022-02-22","objectID":"/resume/:1:1","tags":["Resume"],"title":"简历","uri":"/resume/"},{"categories":["Resume"],"content":"教育背景 上海工程技术大学 本科 2012~2016 ","date":"2022-02-22","objectID":"/resume/:1:2","tags":["Resume"],"title":"简历","uri":"/resume/"},{"categories":["Resume"],"content":"证书 系统架构设计师 高级 2021.11 ","date":"2022-02-22","objectID":"/resume/:1:3","tags":["Resume"],"title":"简历","uri":"/resume/"},{"categories":["Resume"],"content":"工作经历 吉林高邦科技有限公司: 后台开发组长, iOS开发组长 – 2018.04~至今  『长春市职业能力建设服务端』: 开发组长, 项目的开发, 需求沟通, 迭代, 各类维护等. 负载均衡, 解释器, 主动冗余.  『长春市职业能力建设iOS端』： 针对企业在职职工、在校学生等职业的职业学习信息发布, 上课的平台. 完成项目框架的搭建, 完善, 维护, 迭代, 发布等.  『房坐标』： 是一款针对销售经纪人的平台软件. 负责iOS端项目的搭建到上架的全部过程, 服务端的运维. 江苏磊响科技有限公司: iOS开发 – 2017.03~2018.03  『学好』：专业定制的校园富媒体平台.  『童行』：家长和幼儿园之间的沟通平台.  完成项目框架的搭建, 完善, 功能的研发, 发布和定期维护. 南京跃豚智能科技有限公司: iOS开发 – 2016.05~2017.03  『紫金蘭杉』：南理工校友交流平台.  『悟空秀』：发布个人编辑的文章、美图.  『Saprotan』：印尼的相关农业交流平台.  完成软件相关模块的研发以及整个项目的维护. 完成Appstore的上架, 新版本的发布. ","date":"2022-02-22","objectID":"/resume/:1:4","tags":["Resume"],"title":"简历","uri":"/resume/"},{"categories":["Resume"],"content":"技术栈 编程语言: Java, Swift, Objective-C Java框架: SpringBoot, SpringCloud, SpringMVC 数据库: MySQL, Redis, 达梦, Elasticsearch 开发工具: IntelliJ IDEA, Xcode, VSCode, git, svn, maven, cocoapods, SwiftPackage 操作系统: Linux常用命令 Web开发(了解): HTML5、JS、Ajax、vue框架、element-UI组件等 ","date":"2022-02-22","objectID":"/resume/:1:5","tags":["Resume"],"title":"简历","uri":"/resume/"},{"categories":["Resume"],"content":"自我评价 虽然Java开发的项目经验比较少, 但是有技术热情和较强的学习能力, 对于新技术有浓烈的好奇心, 能够深入了解开源技术、现有系统技术等相关技术原理, 有很好的问题分析和技术攻关能力, 具有良好的团队合作能力、沟通能力、抗压能力、责任心. 简历附件 ","date":"2022-02-22","objectID":"/resume/:1:6","tags":["Resume"],"title":"简历","uri":"/resume/"},{"categories":null,"content":"Java Overview (Java Platform SE 8 ) (oracle.com) Java 8 中文版 Overview (Java SE 11 \u0026 JDK 11 ) (oracle.com) Java 11 中文版 Nacos ","date":"2022-02-22","objectID":"/documents/:1:0","tags":null,"title":"文档","uri":"/documents/"},{"categories":null,"content":"iOS Swift - Resources - Apple Developer Vapor Xcode Releases ","date":"2022-02-22","objectID":"/documents/:2:0","tags":null,"title":"文档","uri":"/documents/"},{"categories":null,"content":"Other 力扣（LeetCode）中国官网 Markdown 入门基础 | Markdown 官方教程 飞桨PaddlePaddle-源于产业实践的开源深度学习平台 Elasticsearch Guide 8.0 ","date":"2022-02-22","objectID":"/documents/:3:0","tags":null,"title":"文档","uri":"/documents/"},{"categories":["MySQL"],"content":"有了数据库之后, 还需要先进行压测 拿到一个数据库之后, 首先得先对这个数据库进行一个较为基本的基准压测. 也就是说, 你得基于一些工具模拟一个系统每秒发出1000个请求到数据库上去, 观察一下他的CPU负载、磁盘IO负载、网络 IO负载、内存复杂, 然后数据库能否每秒处理掉这1000个请求, 还是每秒只能处理500个请求? 这个过程, 就是压测. 那为什么不等到Java系统都开发完之后, 直接让Java系统连接上MySQL数据库, 然后直接对Java系统进行压测呢? 因为数据库的压测和它上面的Java系统的压测, 其实是两回事, 首先得知道数据库最大能抗多大压力, 然后再去看Java系统能抗多大压力. 因为有一种可能是, 数据库每秒可以抗下2000个请求, 但是Java系统每秒只能抗下500个请求. 所以不能光是对Java系统去进行压测, 在那之前也得先对数据库进行压测, 做到心里有个数. ","date":"2022-01-10","objectID":"/mysql_4/:1:0","tags":["database","MySQL"],"title":"MySQL压力测试","uri":"/mysql_4/"},{"categories":["MySQL"],"content":"QPS和TPS到底有什么区别 既然是要压测, 那么肯定得先明白一点, 每秒能抗下多少个请求, 其实是有专业术语的, 分别是QPS和TPS. QPS: Query Per Second. 也就是说数据库每秒可以处理多少个请求, 大致可以理解为一次请求就是一条SQL语句, 也就是说数据库可以每秒处理多少个SQL语句. Java系统或者中间件系统在进行压测的时候, 也可以使用这个指标. TPS: Transaction Per Second. 指的是每秒可以处理的事务量. 就是说数据库可以每秒处理多少次事务提交或者回滚. ","date":"2022-01-10","objectID":"/mysql_4/:2:0","tags":["database","MySQL"],"title":"MySQL压力测试","uri":"/mysql_4/"},{"categories":["MySQL"],"content":"IO相关的压测性能指标 IOPS: 指的是机器的随机IO并发处理能力. 举个🌰: 机器可以达到200 IOPS, 意思就是说每秒可以执行200个随机IO读写请求. 这个指标很关键, 因为在之前说过, 在内存中更新的脏数据库, 最后都由后台IO线程在不确定的时间, 刷回到磁盘中去, 这就是随机IO的过程. 也就是说, 如果IOPS指标太低, 那么就会导致内存里的脏数据库刷回磁盘的效率不高. 吞吐量: 指的是机器的磁盘存储每秒可以读写多少字节的数据量. 这个指标也很关键, 之前也说过, 在执行各种SQL语句的时候, 提交事务的时候, 其实都是大量的会写redo log之类的日志的, 这些日志都会直接写磁盘文件. 所以一台机器的存储每秒可以读写多少字节的数据量, 就决定了他每秒可以把多少redo log之类的日志写入到磁盘里去. 一般来说, 我们写redo log之类的日志, 都是对磁盘文件进行顺序写入的, 也就是一行接着一行的写, 不会说进行随机的读写, 那么一般普通磁盘的顺序写入的吞吐量每秒都可以达到200MB左右. 所以通常而言, 机器的磁盘吞吐量都是足够承载高并发请求的. latency: 指的是往磁盘里写入一条数据的延迟. 这个指标同样重要, 因为执行SQL语句的和提交事务的时候, 都需要顺序写redo log磁盘文件, 所以此时写一条日志到磁盘文件里去, 到底是延迟1ms, 还是延迟100us, 这就对数据库的SQL语句执行性能是有影响的. ","date":"2022-01-10","objectID":"/mysql_4/:3:0","tags":["database","MySQL"],"title":"MySQL压力测试","uri":"/mysql_4/"},{"categories":["MySQL"],"content":"压测的时候要关注的其他性能指标 CPU负载: 这个也是一个很重要的指标. 因为假设数据库压测到了3000 QPS, 可能其他指标都还正常, 但是此时CPU负载特别高, 那么也说明你的数据库不能继续往下压测更高的QPS了, 否则CPU是吃不消的. 网络负载: 这个就是看机器带宽情况下, 在压测到一定的QPS和TPS的时候, 每秒钟机器的网卡会输入多少MB数据, 会输出多少MB数据. 因为有可能网络带宽最多每秒传输100MB的数据, 那么可能QPS到1000的时候, 网卡就打满了, 已经每秒传输100MB的数据了, 此时即使其他指标还正常, 也不能继续压测下去了. 内存负载: 这个就是看压测到一定情况下的时候, 机器内存损耗了多少, 如果说机器内存损耗过高了, 说明也不能继续压测下去了. ","date":"2022-01-10","objectID":"/mysql_4/:4:0","tags":["database","MySQL"],"title":"MySQL压力测试","uri":"/mysql_4/"},{"categories":["MySQL"],"content":"推荐压测工具 sysbench, 这个工具可以自动帮你在数据库里构建出来大量的数据. 然后也可以模拟几千个线程并发的访问数据库, 模拟各种sql语句, 包括各种书屋提交到数据库里, 甚至可以模拟出几十万的TPS对数据库进行压测. ","date":"2022-01-10","objectID":"/mysql_4/:5:0","tags":["database","MySQL"],"title":"MySQL压力测试","uri":"/mysql_4/"},{"categories":["MySQL"],"content":"生产数据库一般用什么配置的机器 首先要明确的一点, 如果系统是一个没什么并发访问量, 用户就几十个人或者几百个人的系统, 那么其实选择什么样的机器去部署数据库, 影响不大. 哪怕是个人笔记本电脑去部署一个MySQL数据库, 其实也能支撑地并发系统的运行. 因为这种系统可能每个几分钟才会有一波请求发到数据库上, 而且数据库里一张表也许就几百条, 几千条或者是几万条. 数据量很小, 并发量很小, 操作频率很低, 用户量很小, 并发量很小, 只不过可能系统的业务逻辑很复杂而已. 对于这类系统的数据库机器选型, 什么样都可以. ","date":"2021-12-27","objectID":"/mysql_3/:1:0","tags":["database","MySQL"],"title":"MySQL生产经验","uri":"/mysql_3/"},{"categories":["MySQL"],"content":"普通的Java应用系统部署在机器上能抗多少并发 通常来说, Java应用系统部署的时候常选用的机器配置大致是2核4G和4核8G的较多一些, 数据库部署的时候常选用的机器配置最低在8核16G以上, 正常在16核32G. 那么以大量的高并发线上系统的生产经验观察下来而言, 一般Java应用系统部署在4核8G的机器上, 每秒钟抗下500左右的并发访问量, 差不多是比较合适的. 当然这个也不是绝对的, 假设每个请求花费1s可以处理完, 那么一台机器每秒也许只可以处理100个请求, 但是如果每个请求只要花费100ms就可以处理完, 那么一台机器每秒也许就可以处理几百个请求. 所以一台机器能抗下每秒多少请求, 往往是跟每个请求处理耗费多长时间关联的. 但是大体上来说, 根据大量的经验观察而言, 4核8G的机器部署普通的Java应用系统, 每秒大致能抗下几百的并发访问, 从每秒一两百请求到每秒七八百请求, 都是有可能的, 关键是每个请求耗费多长时间. ","date":"2021-12-27","objectID":"/mysql_3/:2:0","tags":["database","MySQL"],"title":"MySQL生产经验","uri":"/mysql_3/"},{"categories":["MySQL"],"content":"高并发场景下, 数据库应该用什么样的机器 对于数据库而言, 上文也说了, 通常推荐的数据至少是选用8核16G以上的机器更加合适. 因为要考虑一个问题, 对于我们的Java应用系统, 主要耗费时间的是Java系统和数据库之间的网络通信. 对Java系统自己而言, 如果仅仅只是系统内部运行一些普通的业务逻辑, 纯粹在自己内存中完成一些业务逻辑, 这个性能是极高极高的. 对于Java系统受到的每个请求, 耗时最多的还是发送网络请求到数据库上去, 等待数据库执行一些SQL语句, 返回结果给Java系统. 所以其实常说的Java系统压力很大, 负载很高. 其实主要的压力和复杂都是集中在依赖的那个MySQL数据库上! 因为执行大量的增删改查的SQL语句的时候, MySQL数据库需要对内存和磁盘文件进行大量的IO操作, 所以数据库往往是负载最高的! 通过经验而言, 一般8核16G的机器部署的MySQL数据库, 每秒抗个一两千并发请求是没问题的, 但是如果并发量再高一些, 假设每秒有几千并发请求, 那么可能数据库就会有危险了, 因为数据库的CPU、磁盘、IO、内存的负载都会很高, 弄不好数据库压力过大就会宕机. 对于16核32G的机器部署的MySQL数据库而言, 每秒两三千, 甚至三四千的并发也都是可以的, 但是如果达到每秒上万请求, 也是会有宕机的危险. 如果可以的话, 数据库机器周最好用SSD的硬盘而不是机械硬盘. ","date":"2021-12-27","objectID":"/mysql_3/:3:0","tags":["database","MySQL"],"title":"MySQL生产经验","uri":"/mysql_3/"},{"categories":["MySQL"],"content":"申请机器机器之后做好心中有数, 交给专业的DBA部署 数据库机器申请下来之后, 作为架构师要对机器做到心中有数. 比如申请的是8核16G的机器, 心里大致就该知道这个数据库每秒抗个一两千请求是可以的, 如果申请的是16核32G的机器, 那心里知道妥妥可以抗个每秒两三千, 甚至三四千的请求. 其次, 申请一台机器下来之后, 接着这台机器在有一定规模的公司里, 一定是交给公司专业的DBA去安装、部署和启动MySQL的. DBA这个时候会按照他国王的经验, 用自己的MySQL生产调优参数模板, 直接放到MySQL里去, 然后用一个参数模板去启动这个MySQL, 往往这里很多参数都是调优过的. 而且DBA还可能对linux机器一些OS内核参数进行一定的调整, 比如说最大文件句柄之类的参数, 这些参数往往也都是需要调整的. ","date":"2021-12-27","objectID":"/mysql_3/:4:0","tags":["database","MySQL"],"title":"MySQL生产经验","uri":"/mysql_3/"},{"categories":["MySQL"],"content":"什么是InnoDB? InnoDB是第一个提供外键约束的存储引擎, 而且它对事务的处理能力是其它存储引擎无法与之比拟的. MySQL在5.5版本之后, 默认存储引擎由MyISAM修改为InnoDB. 目前, InnoDB是最重要的, 也是使用最广泛的存储引擎. 1. InnoDB优势: 支持事务安装 灾难恢复性好 使用行级锁 实现了缓冲处理 支持外键 适合需要大型数据库的网站 2. 物理存储 数据文件(表数据和索引数据): 共享表空间 独立表空间 日志文件 ","date":"2021-12-23","objectID":"/mysql_2/:1:0","tags":["database","MySQL"],"title":"InnoDB存储引擎的架构设计","uri":"/mysql_2/"},{"categories":["MySQL"],"content":"更新语句在MySQL中是如何执行的? 首先假设有一条语句是这样的: UPDATEusersSETname='xxx'WHEREid=10 这条语句是如何执行的呢? 首先肯定是系统通过一个数据库连接发送到了MySQL上, 然后经过SQL接口、解析器、优化器、执行器几个环节, 解析SQL语句, 生成执行计划, 接着由执行器负责这个计划的执行, 调用InnoDB存储引擎的接口去执行. ","date":"2021-12-23","objectID":"/mysql_2/:2:0","tags":["database","MySQL"],"title":"InnoDB存储引擎的架构设计","uri":"/mysql_2/"},{"categories":["MySQL"],"content":"InnoDB的重要内存结构: 缓冲池 前面提到了InnoDB的一个优势就是\"实现了缓冲处理\", 就是通过InnoDB存储引擎中的一个非常重要的放在内存里的组件实现的, 就是缓冲池(Buffer Pool). 这个里面会存很多数据, 便于以后的查询, 要是缓冲池里有数据, 就不会去磁盘查询. 所以当执行上面那条更新语句的时候, 就会现将id=10这一行数据看看是否在缓冲池里, 如果不在的话, 那么会直接从磁盘里加载到缓冲池里来, 而且还会对这行记录加锁. ","date":"2021-12-23","objectID":"/mysql_2/:3:0","tags":["database","MySQL"],"title":"InnoDB存储引擎的架构设计","uri":"/mysql_2/"},{"categories":["MySQL"],"content":"undo日志文件: 如何让你更新的数据可以回滚 接着下一步, 假设id=10这行数据的name原来是\"zhangsan\", 现在我们更新为\"xxx\", 那么此时得现将要更新的原来的值\"zhangsan\"和id=10这些信息, 写入到undo日志文件中去. 其实大家都知道, 如果执行一个更新语句是在一个事务里的话, 那么事务提交之前我们都是可以对数据进行**回滚(rollback)**的. ","date":"2021-12-23","objectID":"/mysql_2/:4:0","tags":["database","MySQL"],"title":"InnoDB存储引擎的架构设计","uri":"/mysql_2/"},{"categories":["MySQL"],"content":"更新buffer pool中的缓存数据 当我们把要更新的那行记录从磁盘文件加载到缓冲池, 也对其进行加锁之后, 并且还把更新前的旧值写入undo日志文件之后, 就可以正式开始更新这行记录了. 更新的时候, 先是会更新缓冲池中的记录, 此时这个数据就是脏数据了. 为什么是脏数据: 因为此时的磁盘中id=10这行数据的name还是\"zhangsan\", 还不是\"xxx\". ","date":"2021-12-23","objectID":"/mysql_2/:5:0","tags":["database","MySQL"],"title":"InnoDB存储引擎的架构设计","uri":"/mysql_2/"},{"categories":["MySQL"],"content":"Redo Log Buffer: 万一系统宕机, 如何避免数据丢失 如果按照上面的操作进行更新, 现在已经把内存里的数据进行了修改, 但是磁盘上的数据还没有修改. 就在这个时候, 系统宕机了, 该怎么办? 这个时候就必须要把对内存所做的修改写入到一个Redo Log Buffer里去, 这也是一个内存的缓冲区, 用来存放redo日志的. redo日志用来记录对什么记录进行了修改, 比如对id=10这行记录修改了name为\"xxx\", 这就是一个日志. 这个redo日志其实就是用来在MySQL突然宕机的时候, 用来恢复更新过的数据的. ","date":"2021-12-23","objectID":"/mysql_2/:6:0","tags":["database","MySQL"],"title":"InnoDB存储引擎的架构设计","uri":"/mysql_2/"},{"categories":["MySQL"],"content":"如果还没提交事务, MySQL宕机了怎么办 如果还没有提交事务, 那么此时如果MySQL崩溃, 必然导致内存里Buffer Pool中的修改过的数据都丢失, 同时写入Redo Log Buffer中的redo日志也会消失. 其实此时数据丢失是不要紧的, 因为一个更新语句, 没提交事务, 就代表还没有执行成功, 此时MySQL宕机虽然导致内存里的数据都丢失了, 但是会发现, 磁盘上的数据怡然居还停留在原样子. 换句话说, id=10那行数据的name字段的值还是旧值\"zhangsan\", 所以此时这个事务就是执行失败了, 没能成功完成更新, 会收到一个数据库的异常. 然后当MySQL重启之后, 数据并没有任何变化. 所以, 如果还没提交事务时, MySQL宕机了, 不会有任何问题. ","date":"2021-12-23","objectID":"/mysql_2/:7:0","tags":["database","MySQL"],"title":"InnoDB存储引擎的架构设计","uri":"/mysql_2/"},{"categories":["MySQL"],"content":"提交事务的时候将redo日志写入磁盘中 接着俩要提交一个事务了, 此时就会根据一定的策略把redo日志从redo log buffer里刷入到磁盘文件里去. 这个策略是通过innodb_flush_log_at_trx_commit来配置的, 它有几个选项. 当这个参数的值为0的时候, 那么当提交事务的时候, 不会把redo log buffer里的数据刷入磁盘文件, 此时可能都提交事务了, 结果MySQL宕机了, 然后内存里的数据全部丢失了. 这就相当于提交事务成功了, 但是由于MySQL宕机, 导致内存中的数据和redo日志都丢失了. 当这个参数的值为1的时候, 那么当提交事务的时候, 就必须把redo log buffer从内存刷入到磁盘文件里去, 只有事务提交成功, 那么redo log就必然在磁盘里了. 所以只有提交事务成功之后, redo日志一定在磁盘文件里. 也就是说, 哪怕此时buffer pool中更新过的数据还没刷新到磁盘里去, 此时内存里的数据已经是更新过name=\"xxx\", 然后磁盘上的数据还是没更新过的name=\"zhangsan\". 当MySQL重启之后, 可以根据redo日志去恢复之前做过的修改. 当这个参数的值是2的时候, 那么当提交事务的时候, 把redo日志写入磁盘文件对应的os cache里去, 而不是直接进入磁盘文件, 可能1秒之后才会吧os cache里的数据写入到磁盘文件里去. 这种模式下, 提交事务之后, redo log可能仅仅停留在os cache内存缓存里, 没实际进入磁盘文件, 玩意此时要是机器宕机了, 那么os cache里的redo log就会丢失, 同样会感觉提交事务了, 但是结果数据丢了. ","date":"2021-12-23","objectID":"/mysql_2/:8:0","tags":["database","MySQL"],"title":"InnoDB存储引擎的架构设计","uri":"/mysql_2/"},{"categories":["MySQL"],"content":"什么是CRUD? CRUD是指在做计算处理时的增加(Create), 读取查询(Retrieve), 更新(Update)和删除(Delete). 主要是被用在描述软件系统中DataBase或者持久层的基本操作. ","date":"2021-12-13","objectID":"/mysql_1/:1:0","tags":["database","MySQL"],"title":"MySQL总览","uri":"/mysql_1/"},{"categories":["MySQL"],"content":"什么是数据库驱动? 想要访问数据库, 就需要和数据库建立一个网络连接. 那么, 建立这个网络连接的就是数据库驱动. 所以对于MySQL来说, 对应每种常见的编程语言(e.g. Java, PHP, .NET, Python, Ruby等), MySQL都会提供对应语言的MySQL驱动. 其实数据库驱动就是中间件. ","date":"2021-12-13","objectID":"/mysql_1/:2:0","tags":["database","MySQL"],"title":"MySQL总览","uri":"/mysql_1/"},{"categories":["MySQL"],"content":"数据库连接池是用来干嘛的? 首先要知道的是, 一个系统和数据库建立的连接往往都不止一个. 但是每次访问数据库的时候都建立一个连接, 然后执行SQL语句, 然后再销毁这个连接, 这种方式显然是不合适的. 因为每次建立一个数据库连接都很耗时, 效率会很低下. 所以, 就出现了数据库连接池这个东西. 一个数据库连接池里会维持多个连接, 让多个线程使用里面的不同的数据库连接去执行SQL语句, 执行完语句之后, 不是销毁这个连接, 而是把它放回池子里, 后面还能继续用. 常见的数据库连接池有DBCP, C3P0, Druid ","date":"2021-12-13","objectID":"/mysql_1/:3:0","tags":["database","MySQL"],"title":"MySQL总览","uri":"/mysql_1/"},{"categories":["MySQL"],"content":"MySQL是如何执行一条SQL语句的? ","date":"2021-12-13","objectID":"/mysql_1/:4:0","tags":["database","MySQL"],"title":"MySQL总览","uri":"/mysql_1/"},{"categories":["MySQL"],"content":"第一步 线程: 接收SQL语句 首先, 假设数据库服务器的连接池中的某个连接收到了网络请求, 假设就是一条SQL语句, 这个工作一定是一个线程来进行处理的, 来监听请求以及读取请求数据. 当MySQL的工作线程接收到SQL语句之后, 会转交给SQL接口去执行. SQL接口(SQL Interface)就是MySQL内部提供的一个组件, 是一套执行SQL语句的接口. ","date":"2021-12-13","objectID":"/mysql_1/:4:1","tags":["database","MySQL"],"title":"MySQL总览","uri":"/mysql_1/"},{"categories":["MySQL"],"content":"第二步 SQL接口: 解析SQL语句 那么, SQL接口又是如何执行SQL语句的呢? 比如要执行下面这条语句: SELECTid,name,ageFROMusersWHEREid=1; MySQL本身也是一个系统, 是一个数据库管理系统(DBMS), 是没法直接理解这些语句的, 所以就需要**查询解析器(Parser)**出场了! 这个查询解析器是负责对SQL语句进行解析的, 比如上面的语句拆解一下, 可以拆解为一下几个部分: 我们现在要从users表里查询数据 查询id字段的值等于1的那行数据 对查出来的哪行数据要提取里面的id, name, age三个字段 所谓的SQL解析, 就是按照既定的SQL语法, 对我们按照SQL语法规则编写的SQL语句进行解析, 然后理解这个SQL语句要干什么事情. ","date":"2021-12-13","objectID":"/mysql_1/:4:2","tags":["database","MySQL"],"title":"MySQL总览","uri":"/mysql_1/"},{"categories":["MySQL"],"content":"第三步 查询优化器: 选择最优查询路径 当通过解析器理解了SQL语句要干什么之后, 接着就会找**查询优化器(Optimizer)**来选择一个最优的查询路径. ","date":"2021-12-13","objectID":"/mysql_1/:4:3","tags":["database","MySQL"],"title":"MySQL总览","uri":"/mysql_1/"},{"categories":["MySQL"],"content":"第四步 存储引擎: 调用存储引擎接口, 真正执行SQL语句 最后一步, 就是把查询优化器选择的最有查询路径交给底层的存储引擎去真正的执行. 存储引擎是MySQL架构设计中很有特色的一个环节. 在真正执行SQL语句的时候, 要不是更新数据, 要不是查询数据, 但是具体的数据是存放在内存里还是在磁盘里呢? 这个时候就需要存储引擎了, 存储引擎其实就是执行SQL语句的, 它是按照一定的步骤去查询内存缓存数据, 更新磁盘数据, 查询磁盘数据等等, 执行诸如此类的一系列的操作. MySQL的架构设计中, SQL接口, SQL解析器, 查询优化器其实都是通用的, 就是一套组件而已. 但是是支持各种各样的存储引擎的, 比如常见的InnoDB, MyISAM, Memory等等, 我们是可以选择使用哪种存储引擎来负责具体的SQL语句执行的. ","date":"2021-12-13","objectID":"/mysql_1/:4:4","tags":["database","MySQL"],"title":"MySQL总览","uri":"/mysql_1/"},{"categories":["MySQL"],"content":"第五步 执行器: 根据执行计划调用存储引擎的接口 现在回过头来看一个问题, 存储引擎可以访问内存和磁盘上的数据, 那么是谁来调用存储引擎的接口呢? 其实还漏了一个执行器的概念, 执行器会根据优化器选择的执行方案, 去调用存储引擎的接口按照一定的顺序和步骤, 就把SQL语句的逻辑给执行了. 举个🌰: 比如执行器可能会先调用存储引擎的一个接口, 去获取users表中的第一行数据, 然后判断一下这个数据的id字段的值是否等于我们期望的值, 如果不是的话, 就继续调用存储引擎的接口, 去获取users表的下一行数据. 基于上述的思路, 执行器就会去根据优化器生成的一套执行计划, 然后不停的调用存储引擎的各种接口去完成SQL语句的执行计划, 大致就是不听的更新或者提取一些数据出来. ","date":"2021-12-13","objectID":"/mysql_1/:4:5","tags":["database","MySQL"],"title":"MySQL总览","uri":"/mysql_1/"},{"categories":null,"content":"初衷 Since: 2021-11-20 08:27:00 ","date":"2021-11-20","objectID":"/about/:1:0","tags":null,"title":"关于 Buli Home","uri":"/about/"},{"categories":null,"content":"期许 不卑不亢，不矜不伐，戒骄戒躁 不嗔不怒，不争不弃，独善其身 ","date":"2021-11-20","objectID":"/about/:2:0","tags":null,"title":"关于 Buli Home","uri":"/about/"},{"categories":null,"content":"About me 在职: iOS开发程序猿, Java开发程序猿 用我所学, 学我所用. 不盲目堆叠技术栈, 保持谦逊, 保持探索欲, 砥砺前行. ","date":"2021-11-20","objectID":"/about/:3:0","tags":null,"title":"关于 Buli Home","uri":"/about/"},{"categories":null,"content":"Other Annual Summary /years/ ","date":"2021-11-20","objectID":"/about/:4:0","tags":null,"title":"关于 Buli Home","uri":"/about/"}]